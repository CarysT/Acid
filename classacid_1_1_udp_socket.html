<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.8.18"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Acid: acid::UdpSocket Class Reference</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">Acid
								&#160;<span id="projectnumber">0.14.1</span>
							</div>
							<div id="projectbrief">A high speed C++17 Vulkan game engine.</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceacid.html">acid</a></li><li class="navelem"><a class="el" href="classacid_1_1_udp_socket.html">UdpSocket</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">acid::UdpSocket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A UDP socket is a connectionless socket. Instead of connecting once to a remote host, like TCP sockets, it can send to and receive from any host at any time.  
 <a href="classacid_1_1_udp_socket.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_udp_socket_8hpp_source.html">UdpSocket.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for acid::UdpSocket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classacid_1_1_udp_socket.png" usemap="#acid::UdpSocket_map" alt=""/>
  <map id="acid::UdpSocket_map" name="acid::UdpSocket_map">
<area href="classacid_1_1_socket.html" title="This class mainly defines internal stuff to be used by derived classes." alt="acid::Socket" shape="rect" coords="0,0,102,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a81f7669b35dc8d499f23a80a4378ac3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_udp_socket.html#a81f7669b35dc8d499f23a80a4378ac3f">UdpSocket</a> ()</td></tr>
<tr class="separator:a81f7669b35dc8d499f23a80a4378ac3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700017ffce2e73df46617e495d31d832"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_udp_socket.html#a700017ffce2e73df46617e495d31d832">GetLocalPort</a> () const</td></tr>
<tr class="separator:a700017ffce2e73df46617e495d31d832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae395daf1e852a619feeb5facc16fc22e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_udp_socket.html#ae395daf1e852a619feeb5facc16fc22e">Bind</a> (uint16_t port, const <a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;address=<a class="el" href="classacid_1_1_ip_address.html#ad496438885879016e97aef5ed6a4430f">IpAddress::Any</a>)</td></tr>
<tr class="separator:ae395daf1e852a619feeb5facc16fc22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababbba91a044fdedd7c8d4ee08b0a355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_udp_socket.html#ababbba91a044fdedd7c8d4ee08b0a355">Unbind</a> ()</td></tr>
<tr class="separator:ababbba91a044fdedd7c8d4ee08b0a355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099fa0f6823dbcf4ffbe9c3881361e5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_udp_socket.html#a099fa0f6823dbcf4ffbe9c3881361e5e">Send</a> (const void *data, std::size_t size, const <a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;remoteAddress, uint16_t remotePort)</td></tr>
<tr class="separator:a099fa0f6823dbcf4ffbe9c3881361e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2ed6fcc544c1916affae4acab91b72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_udp_socket.html#aae2ed6fcc544c1916affae4acab91b72">Receive</a> (void *data, std::size_t size, std::size_t &amp;received, <a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;remoteAddress, uint16_t &amp;remotePort)</td></tr>
<tr class="separator:aae2ed6fcc544c1916affae4acab91b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa735b56337cf3219734120a61206a4d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_udp_socket.html#aa735b56337cf3219734120a61206a4d4">Send</a> (<a class="el" href="classacid_1_1_packet.html">Packet</a> &amp;packet, const <a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;remoteAddress, uint16_t remotePort)</td></tr>
<tr class="separator:aa735b56337cf3219734120a61206a4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f37340b7102f9d60e0ea3f5e4c8cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_udp_socket.html#a26f37340b7102f9d60e0ea3f5e4c8cbc">Receive</a> (<a class="el" href="classacid_1_1_packet.html">Packet</a> &amp;packet, <a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;remoteAddress, uint16_t &amp;remotePort)</td></tr>
<tr class="separator:a26f37340b7102f9d60e0ea3f5e4c8cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classacid_1_1_socket"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classacid_1_1_socket')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classacid_1_1_socket.html">acid::Socket</a></td></tr>
<tr class="memitem:ae1dcc0f4c23703f49545f050c6e3797b inherit pub_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#ae1dcc0f4c23703f49545f050c6e3797b">~Socket</a> ()</td></tr>
<tr class="separator:ae1dcc0f4c23703f49545f050c6e3797b inherit pub_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec9ae6d03a1362d4d51ad0832ec4bcb inherit pub_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#a2ec9ae6d03a1362d4d51ad0832ec4bcb">IsBlocking</a> () const</td></tr>
<tr class="separator:a2ec9ae6d03a1362d4d51ad0832ec4bcb inherit pub_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9eabeb15c40e5813e8a57384bde4122 inherit pub_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#af9eabeb15c40e5813e8a57384bde4122">SetBlocking</a> (bool <a class="el" href="classacid_1_1_socket.html#a314b6b891e54115b84cf14d572ef1d8d">blocking</a>)</td></tr>
<tr class="separator:af9eabeb15c40e5813e8a57384bde4122 inherit pub_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5dba5d537c3595a5b4e5e87c67c80560"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_udp_socket.html#a5dba5d537c3595a5b4e5e87c67c80560">buffer</a></td></tr>
<tr class="memdesc:a5dba5d537c3595a5b4e5e87c67c80560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary buffer holding the received data in Receive(Packet).  <a href="classacid_1_1_udp_socket.html#a5dba5d537c3595a5b4e5e87c67c80560">More...</a><br /></td></tr>
<tr class="separator:a5dba5d537c3595a5b4e5e87c67c80560"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classacid_1_1_socket"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classacid_1_1_socket')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classacid_1_1_socket.html">acid::Socket</a></td></tr>
<tr class="memitem:ade3f3f004733c7f7ec396b672d698bbf inherit pub_types_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Status</a> { <br />
&#160;&#160;<a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbfaf92965e2c8a7afb3c1b9a5c09a263636">Status::Done</a>, 
<a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbfadd353567e8118a2b8df4e822e59084ab">Status::NotReady</a>, 
<a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbfa44ffd38a6dea695cbe2b34efdcc6cf27">Status::Partial</a>, 
<a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbfaef70e46fd3bbc21e3e1f0b6815e750c0">Status::Disconnected</a>, 
<br />
&#160;&#160;<a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbfa902b0d55fddef6f8d651fe1035b7d4bd">Status::Error</a>
<br />
 }</td></tr>
<tr class="memdesc:ade3f3f004733c7f7ec396b672d698bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status codes that may be returned by socket functions.  <a href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">More...</a><br /></td></tr>
<tr class="separator:ade3f3f004733c7f7ec396b672d698bbf inherit pub_types_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classacid_1_1_socket"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classacid_1_1_socket')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classacid_1_1_socket.html">acid::Socket</a></td></tr>
<tr class="memitem:ac1e881e220bd78ac114315037ca1adb7 inherit pub_static_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">static sockaddr_in&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#ac1e881e220bd78ac114315037ca1adb7">CreateAddress</a> (uint32_t address, uint16_t port)</td></tr>
<tr class="separator:ac1e881e220bd78ac114315037ca1adb7 inherit pub_static_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8365531a8a68e74194e0aaa5bb1ceca2 inherit pub_static_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceacid.html#a31a7b8bd8a1e4c9063155b4755584082">SocketHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#a8365531a8a68e74194e0aaa5bb1ceca2">InvalidSocketHandle</a> ()</td></tr>
<tr class="separator:a8365531a8a68e74194e0aaa5bb1ceca2 inherit pub_static_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa297a650dcfa007237f00b13acbb781b inherit pub_static_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#aa297a650dcfa007237f00b13acbb781b">CloseSocketHandle</a> (<a class="el" href="namespaceacid.html#a31a7b8bd8a1e4c9063155b4755584082">SocketHandle</a> sock)</td></tr>
<tr class="separator:aa297a650dcfa007237f00b13acbb781b inherit pub_static_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8018ca626b8576c43a44a5609c91b70 inherit pub_static_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#aa8018ca626b8576c43a44a5609c91b70">SetHandleBlocking</a> (<a class="el" href="namespaceacid.html#a31a7b8bd8a1e4c9063155b4755584082">SocketHandle</a> sock, bool block)</td></tr>
<tr class="separator:aa8018ca626b8576c43a44a5609c91b70 inherit pub_static_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b06056ba517787e11fa67d7f5ec30f inherit pub_static_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#a48b06056ba517787e11fa67d7f5ec30f">GetErrorStatus</a> ()</td></tr>
<tr class="separator:a48b06056ba517787e11fa67d7f5ec30f inherit pub_static_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classacid_1_1_socket"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classacid_1_1_socket')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classacid_1_1_socket.html">acid::Socket</a></td></tr>
<tr class="memitem:a65a58cc405da0e657ce857bb8757bfc6 inherit pro_types_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#a65a58cc405da0e657ce857bb8757bfc6">Type</a> { <a class="el" href="classacid_1_1_socket.html#a65a58cc405da0e657ce857bb8757bfc6a30b7fdeebc36988717d0e274cc2e7520">Type::Tcp</a>, 
<a class="el" href="classacid_1_1_socket.html#a65a58cc405da0e657ce857bb8757bfc6a81baba40274ccb30f9fdfa2c73cf0482">Type::Udp</a>
 }</td></tr>
<tr class="separator:a65a58cc405da0e657ce857bb8757bfc6 inherit pro_types_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classacid_1_1_socket"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classacid_1_1_socket')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classacid_1_1_socket.html">acid::Socket</a></td></tr>
<tr class="memitem:a595a07cf665832373e53d8c1aa88438f inherit pro_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#a595a07cf665832373e53d8c1aa88438f">Socket</a> (<a class="el" href="classacid_1_1_socket.html#a65a58cc405da0e657ce857bb8757bfc6">Type</a> <a class="el" href="classacid_1_1_socket.html#a200267c8b3e37064121f1397bb6d398a">type</a>)</td></tr>
<tr class="separator:a595a07cf665832373e53d8c1aa88438f inherit pro_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa9ec03b7028ee2c569d9443ee82e1c inherit pro_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceacid.html#a31a7b8bd8a1e4c9063155b4755584082">SocketHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#aeaa9ec03b7028ee2c569d9443ee82e1c">GetHandle</a> () const</td></tr>
<tr class="separator:aeaa9ec03b7028ee2c569d9443ee82e1c inherit pro_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00533896ed33a230f062ae6c688da465 inherit pro_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#a00533896ed33a230f062ae6c688da465">Create</a> ()</td></tr>
<tr class="separator:a00533896ed33a230f062ae6c688da465 inherit pro_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a73af11a47d0fa72171ef797b8415 inherit pro_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#aa13a73af11a47d0fa72171ef797b8415">Create</a> (<a class="el" href="namespaceacid.html#a31a7b8bd8a1e4c9063155b4755584082">SocketHandle</a> handle)</td></tr>
<tr class="separator:aa13a73af11a47d0fa72171ef797b8415 inherit pro_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc1c0b3bc209bf3353ee4a8359acfba inherit pro_methods_classacid_1_1_socket"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classacid_1_1_socket.html#abfc1c0b3bc209bf3353ee4a8359acfba">Close</a> ()</td></tr>
<tr class="separator:abfc1c0b3bc209bf3353ee4a8359acfba inherit pro_methods_classacid_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A UDP socket is a connectionless socket. Instead of connecting once to a remote host, like TCP sockets, it can send to and receive from any host at any time. </p>
<p>It is a datagram protocol: bounded blocks of data (datagrams) are transfered over the network rather than a continuous stream of data (TCP). Therefore, one call to send will always match one call to receive (if the datagram is not lost), with the same data that was sent.</p>
<p>The UDP protocol is lightweight but unreliable. Unreliable means that datagrams may be duplicated, be lost or arrive reordered. However, if a datagram arrives, its data is guaranteed to be valid.</p>
<p>UDP is generally used for real-time communication (audio or video streaming, real-time games, etc.) where speed is crucial and lost data doesn't matter much.</p>
<p>Sending and receiving data can use either the low-level or the high-level functions. The low-level functions process a raw sequence of bytes, whereas the high-level interface uses packets (see <a class="el" href="classacid_1_1_packet.html" title="Packets provide a safe and easy way to serialize data, in order to send it over the network using soc...">acid::Packet</a>), which are easier to use and provide more safety regarding the data that is exchanged. You can look at the <a class="el" href="classacid_1_1_packet.html" title="Packets provide a safe and easy way to serialize data, in order to send it over the network using soc...">acid::Packet</a> class to get more details about how they work.</p>
<p>It is important to note that <a class="el" href="classacid_1_1_udp_socket.html" title="A UDP socket is a connectionless socket. Instead of connecting once to a remote host,...">UdpSocket</a> is unable to send datagrams bigger than MaxDatagramSize. In this case, it returns an error and doesn't send anything. This applies to both raw data and packets. Indeed, even packets are unable to split and recompose data, due to the unreliability of the protocol (dropped, mixed or duplicated datagrams may lead to a big mess when trying to recompose a packet).</p>
<p>If the socket is bound to a port, it is automatically unbound from it when the socket is destroyed. However, you can unbind the socket explicitly with the Unbind function if necessary, to stop receiving messages or make the port available for other sockets. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a81f7669b35dc8d499f23a80a4378ac3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f7669b35dc8d499f23a80a4378ac3f">&#9670;&nbsp;</a></span>UdpSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">acid::UdpSocket::UdpSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae395daf1e852a619feeb5facc16fc22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae395daf1e852a619feeb5facc16fc22e">&#9670;&nbsp;</a></span>Bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Socket::Status</a> acid::UdpSocket::Bind </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em> = <code><a class="el" href="classacid_1_1_ip_address.html#ad496438885879016e97aef5ed6a4430f">IpAddress::Any</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind the socket to a specific port. Binding the socket to a port is necessary for being able to receive data on that port. You can use the special value Socket::AnyPort to tell the system to automatically pick an available port, and then call getLocalPort to retrieve the chosen port. Since the socket can only be bound to a single port at any given moment, if it is already bound when this function is called, it will be unbound from the previous port before being bound to the new one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Port to bind the socket to. </td></tr>
    <tr><td class="paramname">address</td><td>Address of the interface to bind to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a700017ffce2e73df46617e495d31d832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700017ffce2e73df46617e495d31d832">&#9670;&nbsp;</a></span>GetLocalPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t acid::UdpSocket::GetLocalPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the port to which the socket is bound locally. If the socket is not bound to a port, this function returns 0. </p><dl class="section return"><dt>Returns</dt><dd>Port to which the socket is bound. </dd></dl>

</div>
</div>
<a id="a26f37340b7102f9d60e0ea3f5e4c8cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f37340b7102f9d60e0ea3f5e4c8cbc">&#9670;&nbsp;</a></span>Receive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Socket::Status</a> acid::UdpSocket::Receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classacid_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive a formatted packet of data from a remote peer. In blocking mode, this function will wait until the whole packet has been received. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td><a class="el" href="classacid_1_1_packet.html" title="Packets provide a safe and easy way to serialize data, in order to send it over the network using soc...">Packet</a> to fill with the received data. </td></tr>
    <tr><td class="paramname">remoteAddress</td><td>Address of the peer that sent the data. </td></tr>
    <tr><td class="paramname">remotePort</td><td>Port of the peer that sent the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="aae2ed6fcc544c1916affae4acab91b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2ed6fcc544c1916affae4acab91b72">&#9670;&nbsp;</a></span>Receive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Socket::Status</a> acid::UdpSocket::Receive </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>received</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive raw data from a remote peer. In blocking mode, this function will wait until some bytes are actually received. Be careful to use a buffer which is large enough for the data that you intend to receive, if it is too small then an error will be returned and <em>all</em> the data will be lost. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the array to fill with the received bytes. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum number of bytes that can be received. </td></tr>
    <tr><td class="paramname">received</td><td>This variable is filled with the actual number of bytes received. </td></tr>
    <tr><td class="paramname">remoteAddress</td><td>Address of the peer that sent the data. </td></tr>
    <tr><td class="paramname">remotePort</td><td>Port of the peer that sent the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a099fa0f6823dbcf4ffbe9c3881361e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099fa0f6823dbcf4ffbe9c3881361e5e">&#9670;&nbsp;</a></span>Send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Socket::Status</a> acid::UdpSocket::Send </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send raw data to a remote peer. Make sure that <em>size</em> is not greater than UdpSocket::MAX_DATAGRAM_SIZE, otherwise this function will fail and no data will be sent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the sequence of bytes to send. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to send. </td></tr>
    <tr><td class="paramname">remoteAddress</td><td>Address of the receiver. </td></tr>
    <tr><td class="paramname">remotePort</td><td>Port of the receiver to send the data to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="aa735b56337cf3219734120a61206a4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa735b56337cf3219734120a61206a4d4">&#9670;&nbsp;</a></span>Send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classacid_1_1_socket.html#ade3f3f004733c7f7ec396b672d698bbf">Socket::Status</a> acid::UdpSocket::Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classacid_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classacid_1_1_ip_address.html">IpAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a formatted packet of data to a remote peer. Make sure that the packet size is not greater than UdpSocket::MAX_DATAGRAM_SIZE, otherwise this function will fail and no data will be sent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td><a class="el" href="classacid_1_1_packet.html" title="Packets provide a safe and easy way to serialize data, in order to send it over the network using soc...">Packet</a> to send. </td></tr>
    <tr><td class="paramname">remoteAddress</td><td>Address of the receiver. </td></tr>
    <tr><td class="paramname">remotePort</td><td>Port of the receiver to send the data to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ababbba91a044fdedd7c8d4ee08b0a355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababbba91a044fdedd7c8d4ee08b0a355">&#9670;&nbsp;</a></span>Unbind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void acid::UdpSocket::Unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbind the socket from the local port to which it is bound. The port that the socket was previously bound to is immediately made available to the operating system after this function is called. This means that a subsequent call to bind() will be able to re-bind the port if no other process has done so in the mean time. If the socket is not bound to a port, this function has no effect. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a5dba5d537c3595a5b4e5e87c67c80560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dba5d537c3595a5b4e5e87c67c80560">&#9670;&nbsp;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;char&gt; acid::UdpSocket::buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary buffer holding the received data in Receive(Packet). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Sources/Network/Udp/<a class="el" href="_udp_socket_8hpp_source.html">UdpSocket.hpp</a></li>
<li>Sources/Network/Udp/<a class="el" href="_udp_socket_8cpp.html">UdpSocket.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
		<script src="custom.js"></script>
	</body>
</html>